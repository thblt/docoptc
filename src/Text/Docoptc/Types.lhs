This module provides an abstract representation of a program's command-line options. Values of these types are generated by parsing the input Docopt file, and consumed by the code generators.

> module Text.Docoptc.Types where

> import Data.List (intercalate)

We'll distinguish three types of entities: [options](#options) (-o, --o), [positional arguments](#positionals) and [literal (sub)commands](#commands), and. We'll refer to them collectively as *parameters*.

Parameters
==========

An Parameter is thus represented as a partially recursive algebraic type:

> data Parameter =
>       Option OptionName (Maybe OptionArg)
>     | Positional String
>     | Command String
>     | Optional Parameter
>     | Repeatable Parameter
>     | Mutex [Parameter]
>     | MutImp [Parameter]
>     | Any

> data OptionArg = OptionArg {optionArgName :: String, optionArgDefault :: Maybe String}

> data OptionName = Long LongForm | Short ShortForm | Combined ShortForm LongForm
> type ShortForm = Char
> type LongForm = String

This type thus represents everything the DocOpt syntax is able to express: the three fundamental types are Option, Positional and Command. An option may allow an argument, with a name, and a possible default value.

The meaning of the three next constructors should be transparent; if not, refer to the DocOpt documentation. The latter two may be a bit obscure:

 * `MutImp` (standing for Mutual Implication) partially models the meaning of parentheses in the syntax: indicating that all of its members must be present. It represents constructs such as `[(<arg1> <arg2>)]`,

 * `Any` simply represents the syntax element `[options]`, and means that any option defined but not explicitely present in the usage pattern is allowed.

`show` is implemented as to output parsable DocOpt syntax:

> instance Show Parameter where
>     show (Option x Nothing) = usageShow x
>     show (Option x (Just (OptionArg y _))) = usageShow x ++ "=" ++ y
>     show (Positional x) = x
>     show (Optional x) = "[" ++ show x ++ "]"
>     show (Repeatable x) = show x ++ "..."
>     show (Command x) = x
>     show (Mutex xs) =  showSeparatedList "|" xs
>     show (MutImp x) = "(" ++ show x ++ ")"
>     show (Any) = "[options]"

> instance Show OptionName where
>     show (Long x) = "--" ++ x
>     show (Short x) = "-" ++ [x]
>     show (Combined x y) = "-" ++ [x] ++ ", --" ++ y

> usageShow :: OptionName -> String
> usageShow (Combined x _) = show $ Short x
> usageShow x = show x

> newtype Usage = Usage [Parameter]

> instance Show Usage where
>     show (Usage xs) = showSeparatedList " " xs

> newtype Usages = Usages [Usage]

> instance Show Usages where
>     show (Usages xs) = showSeparatedList "\n" xs

Utility functions
=================

> showSeparatedList :: Show a => String -> [a] -> String
> showSeparatedList sep = intercalate sep . fmap show
